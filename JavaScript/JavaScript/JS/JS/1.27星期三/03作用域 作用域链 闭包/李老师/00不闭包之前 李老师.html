<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>闭包 closure</title>
	</head>
	<body>
		闭包就是一个内部函数访问外部函数声明的局部变量
		函数中的变量名解析，实质上就是在Scope这个集合里的执行时的上下文，全局上下文中查找同名的键，如果找到了，就
		读取这个键对应的值，如果没有，就触发异常 
		 
		函数有一个隐藏的属性Scope(打印不了scope;内存封装，不让你看见)
		作用域scope、作用域链scope chain
		1. js垃圾清理机制"自动引用计数(用一个变量来接着函数)ARC"auto referece count:js中声明的变量， var fun2 = fun() ;
		判定需不需要回收：看有没有人在用它。有，就不回收，有一个指向它引用就加1，没有js引擎就会回收
		
		2. 在js中只有两种作用域:全局作用域、函数作用域(不是局部作用域)
		
		3. 没有放在函数中声明的变量或者对象处于全局作用域中
		4. 所有函数都有一个隐藏的属性scope (本质是集合一样的数组) , 指向了函数的作用域
		5. 函数有两个生命阶段:声明、调用执行
		 
		<script>
			声明时作用域链、执行的时作用域链、执行上下文对象
			
			函数有两个生命阶段:声明、执行，函数有一个隐藏的属性Scope,Scope记录着函数声明时的作用域链
			当函数执行前，首先通过Scope找到自己的声明时的作用域链，在链条的最顶端再追加一个执行上
			下文对象(这个上下文对象中指明了this指哪里、arugments是什么内容 ，函数中的局部变量)
			然后再开始执行。
			如果在函数执行的过程中，又创建一个函数,那么这个内部的的作用域链就是
			当前执行的函数的执行时的作用域链
		</script>
		
	 
		
		<script>
			var a=100;
			function fun(b) {//全局函数,在哪都可以用(放在自己的内部，就像递归了)
				var c=1000;//后面还有代码
			}
			// fun声明时作用域  [{全局作用域对象}] 
			 scope:[ {
				 window:?,
				 a:100,
				 fun:全局的fun函数
			 } ];
			fun(10000);//函数的执行
			// fun执行的时作用域链:找到函数声明时作用域的scope,
			// 在这个作用域(全局作用域)的后面(前面后面都无所谓吗)额外追加一个对象(叫做执行时的上下文对象)
			
			 //函数的执行：执行的准备(创建一个Execute context，存储调用该函数的对象，函数的
			// 参数数组，函数的局部变量（值还未定义）)
			// 与执行(找到变量赋值操作，找到第一个就不再找)		
			// 函数执行完:上下文对象符合销毁吗,
			scope: [
				{//执行时上下文 函数运行时内部会才出现一些关键字this(调用)
				// 对象键名:函数运行时才存在的关键字
					this:window,//this函数直接调用
					arugments:实参列表,
					b:undefined,//指向声明的函数  问题,函数在执行前,所有变量声明要提前
					// 把代码中声明的局部变量的名字,放在执行时的上下文中;此时并没有赋值
					c:undefined,
					//准备好后执行,在此对象中
					// 屏蔽同名的全局变量:因为在调用时先在上下文对象中找,找到以后不再找
					然后访问c,如果上下文对象中有c就赋值1000
				},
				{//{全局作用域对象}
				 window:?,
				 a:100,
				 fun:全局的fun函数
				},			
			];
			
			 
			
			
			
		</script>
	</body>
</html>
