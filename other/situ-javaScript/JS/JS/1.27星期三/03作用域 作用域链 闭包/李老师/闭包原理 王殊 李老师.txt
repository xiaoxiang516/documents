作者：王殊
链接：https://www.zhihu.com/question/19554716/answer/146795877
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

	要真正理解JavaScript里的闭包，就一定要脱离能看得见的js代码，看看在js引擎里，一个函数的创建和执行到底发生了
什么，每一个变量名又是如何解析的。

	首先，每一个函数都有一个隐藏的属性[[Scope]]，这个属性保存着函数的作用域链，它本质上是一个集合，它的每个值
引用一个数据的集合。函数中的变量名解析，实质上就是在[[Scope]]引用的每一个数据的集合里查找同名的键，如果找到了，就
读取这个键对应的值，如果没有，就触发异常。当一个函数被创建的时候，如果这个函数形式上没有父函数，
则[[Scope]]属性的第一个值会引用当前的全局上下文，所有全局变量及其存储的数据都在这个集合里。此时[[Scope]]属性如下：

[    (Global Context)]

	当一个函数被调用的时候，会创建一个Execute context，即运行时上下文，它存储调用该函数的对象，函数的参数数组，
函数的局部变量（值还未定义），该集合会被压入[[Scope]]属性，此时[[Scope]]属性如下：

[    
	(Execute context),    
	(Global Context)
]

	当一个函数返回的时候，引擎只是去除[[Scope]]属性中对运行时上下文的引用，并没有立即销毁它。此时运行时上下文
没有任何引用了，符合了被销毁的条件，在将来的某个时刻会被垃圾收集器销毁。此时[[Scope]]属性如下：

[    
	(Global Context)
]

好了，我们再看看，如果一个函数创建的时候存在父函数会是什么情形：

	当一个子函数被创建时，显然，这个创建是父函数的执行导致的，所以当子函数创建时，父函数已经处于执行阶段，所以父函数的执行上下文已经创建了。同时，因为子函数也在父函数的局部变量作用域内，所以，子函数在创建的时候，除了要引用全局上下文，也需要引用父函数的执行上下文，否则子函数就无法访问父函数的局部变量，违背了设计的要求。此时两个函数的[[Scope]]属性如下：

父函数：
[    
	(Execute context),    
	(Global Context)
]

子函数：
[    
	(Execute context),//这里引用的是父函数的执行上下文，自身的执行上下文此时还未创建。    
	(Global Context)
]

	当一个子函数执行时，因为它同样是函数，所以它同样需要创建自己的执行上下文，当它返回的时候，同样也只
解除[[Scope]]属性中对自身执行上下文的引用，对父函数的执行上下文的引用并没有解除，这意味着，父函数的执行上下文与
子函数本身共存亡了。所以，为什么父函数的局部变量没有被销毁？因为它们所在的执行上下文还被子函数的[[Scope]]属性引用着，只要子函数还存在引用，垃圾收集器就不会销毁它们所在的执行上下文。

注意，因为父函数已经执行完毕了，所以父函数的执行上下文中的局部变量如果有赋值，那此时这些变量也已经有了相应的值。

另外，因为父函数的局部变量并不在全局上下文中，所以它只能在子函数的变量解析中被访问，自然而然就相当于它们是子函数
私有的了。