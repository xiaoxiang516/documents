<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			/* 	在函数中的参数,使用var声明的变量都是局部变量
			局部变量在函数调用(执行) 过程中生效, 执行完毕后参数和局部变量就会被回收掉*/
			function A(m) {
				console.log(m);
				var n = 12;
				console.log(n);
			}
			A(34);

			// 在闭包中内部函数可以使用外部函数的参数和变量
			function B(e) {
				return function() {
					// e++;
					console.log(e);
				}
			}
			// 因力内部函数使用了外部函数的参数或变量,
			// 在外部函数执行完成后,其中的变量e不会被立即回收
		
		
			// 问什么时候被回收
			var f = B(12); //外部函数B()执行完后,内部函数
			/* f=function(){
				console.log(12);
			} */
			// https://www.wiki-wiki.top/baike-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)
			垃圾回收器有两个基本的原理：
			A.考虑某个对象在未来的程序运行中,将不会被访问。
			B.回收这些对象所占用的存储器
			垃圾回收:(垃圾回收最早起源于LISP语言)
			当某个程序占用的一部分内存空间不再被这个程序访问时,这个程序会借助垃圾回收算法向操作系统归还这部分内存空间
			
			
			引用计数收集器
			主条目：引用计数
			最早的也是最简单的垃圾回收实现方法,这种方法为占用物理空间的对象附加一个计数器,当有其他对象引用这个对象时计数器加一,
			反之引用解除时减一。这种算法会定期检查尚未被回收的对象的计数器,为零的话则回收其所占物理空间,因为此时的对象已经无法访问。这种方法无法回收循环引用的存储对象。
 		</script>
	</body>
</html>
