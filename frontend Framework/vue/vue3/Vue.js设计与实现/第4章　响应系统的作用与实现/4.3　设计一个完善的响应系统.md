
## 4.3　设计一个完善的响应系统
解决硬副作用函数名字编码问题（effect）
```javascript
 // 用一个全局变量存储被注册的副作用函数
 let activeEffect
 // effect 函数用于注册副作用函数
 function effect(fn) {
   // 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect
   activeEffect = fn
   // 执行副作用函数
   fn()
 }
 

 //  使用 effect 函数
 effect(
  // 一个匿名的副作用函数
  () => {
    document.body.innerText = obj.text
  }
)


 const obj = new Proxy(data, {
   get(target, key) {
     // 将 activeEffect 中存储的副作用函数收集到“桶”中
     if (activeEffect) {  // 新增
       bucket.add(activeEffect)  // 新增
     }  // 新增
     return target[key]
   },
   set(target, key, newVal) {
     target[key] = newVal
     bucket.forEach(fn => fn())
     return true
   }
 })

// 可以看到，我们使用一个匿名的副作用函数作为 effect 函数的参数。
// 当 effect 函数执行时，首先会把匿名的副作用函数 fn 赋值给全局变量 activeEffect。
// 接着执行被注册的匿名副作用函数 fn，这将会触发响应式数据 obj.text 的读取操作，进而触发代理对象 Proxy 的 get 拦截函数：
```
 在响应式数据 obj 上设置一个不存在的属性与重新设计“桶”的数据结构

```javascript
 effect(
   // 匿名副作用函数
   () => {
     console.log('effect run') // 会打印 2 次
     document.body.innerText = obj.text
   }
 )

 setTimeout(() => {
   // 副作用函数中并没有读取 notExist 属性的值
   obj.notExist = 'hello vue3'
 }, 1000)
```

在副作用函数与被操作的字段之间建立联系
```javaScript
01 // 存储副作用函数的桶
02 const bucket = new WeakMap()
```